require 'yaml'
require 'rhcl'
require 'erb'

# Monkey patch String to unescape quotes
class String
    def unescape
        gsub(/\\\"/,'"')
    end 
end 

# A Cluster YAML file spec is as follows...
#
# kind: the kind of cloud vendor support, must be one of ['gclod', 'azure', 'aws']
# apiVersion: the version of the file spec supported
# metadata:
#   name: the name of the cluster to build. Defaults to basename of the yaml file
# region: the named region (corresponding to the cloud provider's region names)
# backend: configuration for the terraform backend to use
#   kind: the kind of backend to use, must be one of ['s3', 'gcs', 'azurerm']
#   config: provide the name value pairs for the configuration 'kind'
# provider: provide the name value pairs for the cluster 'kind'. Region may be supplied, but will default to 'region'
# kubernetes:
#   version: supply the kubernetes version string

module Cluster
    class Cluster

        Kind = {
            'gcloud': {
                backend: 'gcos',
                provider: 'google'
            },
            'azure': {
                backend: 'azurerm',
                provider: 'azurerm',
            }
        }

        attr_reader :cluster_dir, :name, :kind, :region, :backend, :provider, :kubernetes, :metadata

        def initialize(config_file)
            @root_dir = "./clusters"
            @template_dir = "./template"
            load_config(config_file)
        end

        def load_config(config_file)
            config = "#{@root_dir}/#{config_file}"
            raise "#{self.class.name}.#{__method__} : #{config} must exist and be readable." unless File.readable?(config)

            # Read the yaml and update local variables
            @cluster_attrs = YAML.load(File.read(config))

            # Test and for kind, region, provider and kubernetes: all must be provided
            [ 'apiVersion', 'kind', 'metadata', 'region', 'backend', 'provider', 'kubernetes'].each { |attr_name|
                raise "#{this.class.name}.#{__method__} : #{config} is missing #{attr_name}" unless @cluster_attrs.has_key?(attr_name)
                v = @cluster_attrs[attr_name]
                if self.respond_to?("#{attr_name}=")
                    self.send("#{attr_name}=", v)
                else
                    self.instance_variable_set("@#{attr_name}", v)
                end
            }
            @name = @metadata['name']
            @cluster_dir = "./clusters/#{@name}"
        end

        def init_state
            # Create the cluster directory if necessary
            FileUtils.mkdir_p("#{@root_dir}/#{name}")

            # Create the backend tfvars file
            File.open("#{@cluster_dir}/backend.tfvars", "w") { |file|
                file.write(
                    <<~BACKEND_TFVARS
                    # DO NOT EDIT: Autogenerated TFVARS for the Terraform Backend
                    #{Rhcl.dump(backend['config'])}
                    BACKEND_TFVARS
                )
            }

            # Create the backend tf file
            File.open("#{@cluster_dir}/backend.tf", "w") { |file|
                file.write(
                    <<~BACKEND_TF
                    # DO NOT EDIT: Autogenerated Terraform backend specification
                    terraform "#{backend['kind'] || Kind[kind][:backend]}" {}
                    BACKEND_TF
                )
            }

            # Create the provider tf file
            File.open("#{@cluster_dir}/provider.tf", "w") { |file|
                update_provider
                file.write(
                    <<~PROVIDER_TF
                    # DO NOT EDIT: Autogenerated Terraform provider specification
                    provider "#{Kind[kind.to_sym][:provider]}" {
                    #{Rhcl.dump(map_paths(provider)).gsub(/^/, '  ').unescape }
                    }
                    PROVIDER_TF
                )
            }

            opts = OpenStruct.new({
                kind: kind,
                provider: provider
            })

            File.open("#{@cluster_dir}/terraform.tfvars", "w") { |file|
                file.write(
                    <<~TERRAFORM_TFVARS
                    # DO NOT EDIT: Autogenerated tfvars overrides
                    region = "#{region}"
                    cluster_name = "#{metadata['name']}"
                    #{Rhcl.dump(kubernetes['tfvars']) if kubernetes.has_key?('tfvars')}
                    TERRAFORM_TFVARS
                )
            }

            # TODO: Need to update .erb Node Groups specifically

            # Copy in the erb files and process
            Dir["#{@template_dir}/#{kind}/*.erb*"].each { |src|
                dst = "#{@cluster_dir}/#{File.basename(src).gsub(/\.erb/, '')}"
                File.write(dst, ERB.new(File.read(src)).result(opts.instance_eval {binding}))
            }
        end

        def kind=(v)
            raise('kind must be specidifed and must be one of [aws, gcloud, azure]') unless v && ['aws', 'gcloud', 'azure'].include?(v)
            @kind = v
        end 

        def apiVersion=(v)
            raise 'apiVersion must be specified and only apiVersion v1alpha1 is currently supported' unless v && v == 'v1alpha1'
            @apiVersion = v
        end 

        def provider=(v)
            @provider = v || {}
        end

        def update_provider
            case kind
            when 'gcloud'
                @provider[:region] = region unless @provider.has_key?(:region)
            when 'azure'
                unless @provider.has_key?('subscription_id') && @provider.has_key?('tenant_id')
                    account = JSON.parse `az account show`
                    @provider['subscription_id'] = account['id']
                    @provider['tenant_id'] = account['tenantId']
                end

                unless @provider.has_key?('client_id') && @provider.has_key?('client_secret')
                    sp = JSON.parse `az ad sp create-for-rbac --role contributor --scopes /subscriptions/#{@provider['subscription_id']}`
                    @provider['client_id'] = sp['appId']
                    @provider['client_secret'] = sp['password']
                end
            end
        end

        def init
            Dir.chdir(cluster_dir) do
                MultiTool::Command.run("terraform workspace new #{name}")
                MultiTool::Command.run('terraform init --backend-config backend.tfvars')
            end     
        end 

        def plan
            Dir.chdir(cluster_dir) do
                MultiTool::Command.run("terraform plan --out #{name}.plan")
            end                 
        end

        def apply
            Dir.chdir(cluster_dir) do
                MultiTool::Command.run('terraform apply -auto-approve')
                # MultiTool::Command.run("gcloud container clusters get-credentials terraform-example-cluster --zone us-central1-a --project #{project}"
            end
        end

        def destroy
            Dir.chdir(cluster_dir) do
                MultiTool::Command.run('terraform destroy -force')
            end
        end

        private
        def map_paths(props)
            props.map { |k, v| [k, v.gsub(/^(\~.*)/, '${file("\1")}')] }.to_h
        end
    end
end


namespace :cluster do
    desc 'Initialize the backend state storage for a cluster'
    task :init, [:cluster_name] do |t, args|
        raise "You must supply a cluster name for #{t.name}" unless args.has_key?(:cluster_name)

        c = Cluster::Cluster.new args[:cluster_name]
        c.init_state
        c.init 

    end 

    desc 'Perform a dry-run of a cluster build'
    task :plan, [:cluster_name] do |t, args|
        raise "You must supply a cluster name for #{t.name}" unless args.has_key?(:cluster_name)

        c = Cluster::Cluster.new args[:cluster_name]
        c.plan
    end

    desc 'Perform a cluster build'
    task :apply, [:cluster_name] do |t, args|
        raise "You must supply a cluster name for #{t.name}" unless args.has_key?(:cluster_name)
        raise "You must supply a cluster name for #{t.name}" unless args.has_key?(:cluster_name)

        c = Cluster::Cluster.new args[:cluster_name]
        c.apply
    end

    desc 'Tear down a cluster'
    task :destroy, [:cluster_name] do |t, args|
        raise "You must supply a cluster name for #{t.name}" unless args.has_key?(:cluster_name)

        c = Cluster::Cluster.new args[:cluster_name]
        c.destroy
    end

    desc 'Clean up one or all (default) local cluster files'
    task :clean, [:cluster_name] do |t, args|
        Dir.chdir('./clusters') do
            Dir['*'].select { |f| File.directory? f}.each { |d| FileUtils.rm_rf d}
        end
    end
end